


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: OperatorIntersectionCursor</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.esri.core.geometry</a> ]
</div>

<h1>Coverage Summary for Class: OperatorIntersectionCursor (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OperatorIntersectionCursor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.9%
  </span>
  <span class="absValue">
    (322/ 408)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; Copyright 1995-2015 Esri
<i>3</i>&nbsp;
<i>4</i>&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i>5</i>&nbsp;   you may not use this file except in compliance with the License.
<i>6</i>&nbsp;   You may obtain a copy of the License at
<i>7</i>&nbsp;
<i>8</i>&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp;
<i>10</i>&nbsp;   Unless required by applicable law or agreed to in writing, software
<i>11</i>&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>12</i>&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>13</i>&nbsp;   See the License for the specific language governing permissions and
<i>14</i>&nbsp;   limitations under the License.
<i>15</i>&nbsp;
<i>16</i>&nbsp; For additional information, contact:
<i>17</i>&nbsp; Environmental Systems Research Institute, Inc.
<i>18</i>&nbsp; Attn: Contracts Dept
<i>19</i>&nbsp; 380 New York Street
<i>20</i>&nbsp; Redlands, California, USA 92373
<i>21</i>&nbsp;
<i>22</i>&nbsp; email: contracts@esri.com
<i>23</i>&nbsp; */
<i>24</i>&nbsp;
<i>25</i>&nbsp;package com.esri.core.geometry;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.util.ArrayList;
<i>28</i>&nbsp;
<b class="fc"><i>29</i>&nbsp;class OperatorIntersectionCursor extends GeometryCursor {</b>
<i>30</i>&nbsp;
<i>31</i>&nbsp;	GeometryCursor m_inputGeoms;
<i>32</i>&nbsp;	GeometryCursor m_smallCursor;
<i>33</i>&nbsp;	ProgressTracker m_progress_tracker;
<i>34</i>&nbsp;	SpatialReference m_spatial_reference;
<i>35</i>&nbsp;	Geometry m_geomIntersector;
<i>36</i>&nbsp;	Geometry m_geomIntersectorEmptyGeom;// holds empty geometry of intersector
<i>37</i>&nbsp;										// type.
<i>38</i>&nbsp;	int m_geomIntersectorType;
<i>39</i>&nbsp;	int m_currentGeomType;
<i>40</i>&nbsp;	int m_index;
<i>41</i>&nbsp;	int m_dimensionMask;
<i>42</i>&nbsp;	boolean m_bEmpty;
<i>43</i>&nbsp;
<i>44</i>&nbsp;	OperatorIntersectionCursor(GeometryCursor inputGeoms,
<i>45</i>&nbsp;			GeometryCursor geomIntersector, SpatialReference sr,
<b class="fc"><i>46</i>&nbsp;			ProgressTracker progress_tracker, int dimensionMask) {</b>
<b class="fc"><i>47</i>&nbsp;		m_bEmpty = geomIntersector == null;</b>
<b class="fc"><i>48</i>&nbsp;		m_index = -1;</b>
<b class="fc"><i>49</i>&nbsp;		m_inputGeoms = inputGeoms;</b>
<b class="fc"><i>50</i>&nbsp;		m_spatial_reference = sr;</b>
<b class="fc"><i>51</i>&nbsp;		m_geomIntersector = geomIntersector.next();</b>
<b class="fc"><i>52</i>&nbsp;		m_geomIntersectorType = m_geomIntersector.getType().value();</b>
<b class="fc"><i>53</i>&nbsp;		m_currentGeomType = Geometry.Type.Unknown.value();</b>
<b class="fc"><i>54</i>&nbsp;		m_progress_tracker = progress_tracker;</b>
<b class="fc"><i>55</i>&nbsp;		m_dimensionMask = dimensionMask;</b>
<b class="fc"><i>56</i>&nbsp;		if (m_dimensionMask != -1</b>
<i>57</i>&nbsp;				&amp;&amp; (m_dimensionMask &lt;= 0 || m_dimensionMask &gt; 7))
<b class="nc"><i>58</i>&nbsp;			throw new IllegalArgumentException(&quot;bad dimension mask&quot;);// dimension</b>
<i>59</i>&nbsp;																		// mask
<i>60</i>&nbsp;																		// can
<i>61</i>&nbsp;																		// be
<i>62</i>&nbsp;																		// -1,
<i>63</i>&nbsp;																		// for
<i>64</i>&nbsp;																		// the
<i>65</i>&nbsp;																		// default
<i>66</i>&nbsp;																		// behavior,
<i>67</i>&nbsp;																		// or a
<i>68</i>&nbsp;																		// value
<i>69</i>&nbsp;																		// between
<i>70</i>&nbsp;																		// 1 and
<i>71</i>&nbsp;																		// 7.
<b class="fc"><i>72</i>&nbsp;	}</b>
<i>73</i>&nbsp;
<i>74</i>&nbsp;	@Override
<i>75</i>&nbsp;	public Geometry next() {
<b class="fc"><i>76</i>&nbsp;		if (m_bEmpty)</b>
<b class="nc"><i>77</i>&nbsp;			return null;</b>
<i>78</i>&nbsp;
<i>79</i>&nbsp;		Geometry geom;
<b class="fc"><i>80</i>&nbsp;		if (m_smallCursor != null) {// when dimension mask is used, we produce a</b>
<b class="fc"><i>81</i>&nbsp;			geom = m_smallCursor.next();</b>
<b class="fc"><i>82</i>&nbsp;			if (geom != null)</b>
<b class="fc"><i>83</i>&nbsp;				return geom;</b>
<i>84</i>&nbsp;			else
<b class="fc"><i>85</i>&nbsp;				m_smallCursor = null;// done with the small cursor</b>
<i>86</i>&nbsp;		}
<i>87</i>&nbsp;
<b class="fc"><i>88</i>&nbsp;		while ((geom = m_inputGeoms.next()) != null) {</b>
<b class="fc"><i>89</i>&nbsp;			m_index = m_inputGeoms.getGeometryID();</b>
<b class="fc"><i>90</i>&nbsp;			if (m_dimensionMask == -1) {</b>
<b class="fc"><i>91</i>&nbsp;				Geometry resGeom = intersect(geom);</b>
<b class="fc"><i>92</i>&nbsp;				assert (resGeom != null);</b>
<b class="fc"><i>93</i>&nbsp;				return resGeom;</b>
<i>94</i>&nbsp;			} else {
<b class="fc"><i>95</i>&nbsp;				m_smallCursor = intersectEx(geom);</b>
<b class="fc"><i>96</i>&nbsp;				Geometry resGeom = m_smallCursor.next();</b>
<b class="fc"><i>97</i>&nbsp;				assert (resGeom != null);</b>
<b class="fc"><i>98</i>&nbsp;				return resGeom;</b>
<i>99</i>&nbsp;			}
<i>100</i>&nbsp;		}
<b class="fc"><i>101</i>&nbsp;		return null;</b>
<i>102</i>&nbsp;	}
<i>103</i>&nbsp;
<i>104</i>&nbsp;	@Override
<i>105</i>&nbsp;	public int getGeometryID() {
<b class="nc"><i>106</i>&nbsp;		return m_index;</b>
<i>107</i>&nbsp;	}
<i>108</i>&nbsp;
<i>109</i>&nbsp;	Geometry intersect(Geometry input_geom) {
<b class="fc"><i>110</i>&nbsp;		Geometry dst_geom = tryNativeImplementation_(input_geom);</b>
<b class="fc"><i>111</i>&nbsp;		if (dst_geom != null)</b>
<b class="fc"><i>112</i>&nbsp;			return dst_geom;</b>
<i>113</i>&nbsp;
<b class="fc"><i>114</i>&nbsp;		Envelope2D commonExtent = InternalUtils.getMergedExtent(</b>
<i>115</i>&nbsp;				m_geomIntersector, input_geom);
<i>116</i>&nbsp;
<i>117</i>&nbsp;		// return Topological_operations::intersection(input_geom,
<i>118</i>&nbsp;		// m_geomIntersector, m_spatial_reference, m_progress_tracker);
<i>119</i>&nbsp;		// Preprocess geometries to be clipped to the extent of intersection to
<i>120</i>&nbsp;		// get rid of extra segments.
<b class="fc"><i>121</i>&nbsp;		double t = InternalUtils.calculateToleranceFromGeometry(m_spatial_reference, commonExtent, true);</b>
<b class="fc"><i>122</i>&nbsp;		Envelope2D env = new Envelope2D();</b>
<b class="fc"><i>123</i>&nbsp;		m_geomIntersector.queryEnvelope2D(env);</b>
<b class="fc"><i>124</i>&nbsp;		Envelope2D env1 = new Envelope2D();</b>
<b class="fc"><i>125</i>&nbsp;		input_geom.queryEnvelope2D(env1);</b>
<b class="fc"><i>126</i>&nbsp;		env.inflate(2.0 * t, 2.0 * t);</b>
<b class="fc"><i>127</i>&nbsp;		env.intersect(env1);</b>
<b class="fc"><i>128</i>&nbsp;		assert (!env.isEmpty());</b>
<b class="fc"><i>129</i>&nbsp;		env.inflate(100 * t, 100 * t);</b>
<b class="fc"><i>130</i>&nbsp;		double tol = 0;</b>
<b class="fc"><i>131</i>&nbsp;		Geometry clippedIntersector = Clipper.clip(m_geomIntersector, env, tol,</b>
<i>132</i>&nbsp;				0.0);
<b class="fc"><i>133</i>&nbsp;		Geometry clippedInputGeom = Clipper.clip(input_geom, env, tol, 0.0);</b>
<i>134</i>&nbsp;		// perform the clip
<b class="fc"><i>135</i>&nbsp;		return TopologicalOperations.intersection(clippedInputGeom,</b>
<i>136</i>&nbsp;				clippedIntersector, m_spatial_reference, m_progress_tracker);
<i>137</i>&nbsp;	}
<i>138</i>&nbsp;
<i>139</i>&nbsp;	// Parses the input vector to ensure the out result contains only geometries
<i>140</i>&nbsp;	// as indicated with the dimensionMask
<i>141</i>&nbsp;	GeometryCursor prepareVector_(VertexDescription descr, int dimensionMask,
<i>142</i>&nbsp;			Geometry[] res_vec) {
<b class="fc"><i>143</i>&nbsp;		int inext = 0;</b>
<b class="fc"><i>144</i>&nbsp;		if ((dimensionMask &amp; 1) != 0) {</b>
<b class="fc"><i>145</i>&nbsp;			if (res_vec[0] == null)</b>
<b class="fc"><i>146</i>&nbsp;				res_vec[0] = new MultiPoint(descr);</b>
<b class="fc"><i>147</i>&nbsp;			inext++;</b>
<i>148</i>&nbsp;		} else {
<b class="fc"><i>149</i>&nbsp;			for (int i = 0; i &lt; res_vec.length - 1; i++)</b>
<b class="fc"><i>150</i>&nbsp;				res_vec[i] = res_vec[i + 1];</b>
<i>151</i>&nbsp;		}
<i>152</i>&nbsp;
<b class="fc"><i>153</i>&nbsp;		if ((dimensionMask &amp; 2) != 0) {</b>
<b class="fc"><i>154</i>&nbsp;			if (res_vec[inext] == null)</b>
<b class="fc"><i>155</i>&nbsp;				res_vec[inext] = new Polyline(descr);</b>
<b class="fc"><i>156</i>&nbsp;			inext++;</b>
<i>157</i>&nbsp;		} else {
<b class="fc"><i>158</i>&nbsp;			for (int i = inext; i &lt; res_vec.length - 1; i++)</b>
<b class="fc"><i>159</i>&nbsp;				res_vec[i] = res_vec[i + 1];</b>
<i>160</i>&nbsp;		}
<i>161</i>&nbsp;
<b class="fc"><i>162</i>&nbsp;		if ((dimensionMask &amp; 4) != 0) {</b>
<b class="fc"><i>163</i>&nbsp;			if (res_vec[inext] == null)</b>
<b class="fc"><i>164</i>&nbsp;				res_vec[inext] = new Polygon(descr);</b>
<b class="fc"><i>165</i>&nbsp;			inext++;</b>
<i>166</i>&nbsp;		} else {
<b class="fc"><i>167</i>&nbsp;			for (int i = inext; i &lt; res_vec.length - 1; i++)</b>
<b class="fc"><i>168</i>&nbsp;				res_vec[i] = res_vec[i + 1];</b>
<i>169</i>&nbsp;		}
<i>170</i>&nbsp;		
<b class="fc"><i>171</i>&nbsp;		if (inext != 3) {</b>
<b class="fc"><i>172</i>&nbsp;			Geometry[] r = new Geometry[inext];</b>
<b class="fc"><i>173</i>&nbsp;			for (int i = 0; i &lt; inext; i++)</b>
<b class="fc"><i>174</i>&nbsp;				r[i] = res_vec[i];</b>
<i>175</i>&nbsp;
<b class="fc"><i>176</i>&nbsp;			return new SimpleGeometryCursor(r);</b>
<i>177</i>&nbsp;		} else {
<b class="fc"><i>178</i>&nbsp;			return new SimpleGeometryCursor(res_vec);</b>
<i>179</i>&nbsp;		}
<i>180</i>&nbsp;	}
<i>181</i>&nbsp;
<i>182</i>&nbsp;	GeometryCursor intersectEx(Geometry input_geom) {
<b class="fc"><i>183</i>&nbsp;		assert (m_dimensionMask != -1);</b>
<b class="fc"><i>184</i>&nbsp;		Geometry dst_geom = tryNativeImplementation_(input_geom);</b>
<b class="fc"><i>185</i>&nbsp;		if (dst_geom != null) {</b>
<b class="fc"><i>186</i>&nbsp;			Geometry[] res_vec = new Geometry[3];</b>
<b class="fc"><i>187</i>&nbsp;			res_vec[dst_geom.getDimension()] = dst_geom;</b>
<b class="fc"><i>188</i>&nbsp;			return prepareVector_(input_geom.getDescription(), m_dimensionMask,</b>
<i>189</i>&nbsp;					res_vec);
<i>190</i>&nbsp;		}
<i>191</i>&nbsp;
<b class="fc"><i>192</i>&nbsp;		Envelope2D commonExtent = InternalUtils.getMergedExtent(</b>
<i>193</i>&nbsp;				m_geomIntersector, input_geom);
<b class="fc"><i>194</i>&nbsp;		double t = InternalUtils.calculateToleranceFromGeometry(</b>
<i>195</i>&nbsp;				m_spatial_reference, commonExtent, true);
<i>196</i>&nbsp;
<i>197</i>&nbsp;		// Preprocess geometries to be clipped to the extent of intersection to
<i>198</i>&nbsp;		// get rid of extra segments.
<i>199</i>&nbsp;		
<b class="fc"><i>200</i>&nbsp;		Envelope2D env = new Envelope2D();</b>
<b class="fc"><i>201</i>&nbsp;		m_geomIntersector.queryEnvelope2D(env);</b>
<b class="fc"><i>202</i>&nbsp;		env.inflate(2 * t, 2 * t);</b>
<b class="fc"><i>203</i>&nbsp;		Envelope2D env1 = new Envelope2D();</b>
<b class="fc"><i>204</i>&nbsp;		input_geom.queryEnvelope2D(env1);</b>
<b class="fc"><i>205</i>&nbsp;		env.intersect(env1);</b>
<b class="fc"><i>206</i>&nbsp;		assert (!env.isEmpty());</b>
<b class="fc"><i>207</i>&nbsp;		env.inflate(100 * t, 100 * t);</b>
<b class="fc"><i>208</i>&nbsp;		double tol = 0;</b>
<b class="fc"><i>209</i>&nbsp;		Geometry clippedIntersector = Clipper.clip(m_geomIntersector, env, tol,</b>
<i>210</i>&nbsp;				0.0);
<b class="fc"><i>211</i>&nbsp;		Geometry clippedInputGeom = Clipper.clip(input_geom, env, tol, 0.0);</b>
<i>212</i>&nbsp;		// perform the clip
<i>213</i>&nbsp;		Geometry[] res_vec;
<b class="fc"><i>214</i>&nbsp;		res_vec = TopologicalOperations.intersectionEx(clippedInputGeom,</b>
<i>215</i>&nbsp;				clippedIntersector, m_spatial_reference, m_progress_tracker);
<b class="fc"><i>216</i>&nbsp;		return prepareVector_(input_geom.getDescription(), m_dimensionMask,</b>
<i>217</i>&nbsp;				res_vec);
<i>218</i>&nbsp;	}
<i>219</i>&nbsp;
<i>220</i>&nbsp;	Geometry tryNativeImplementation_(Geometry input_geom) {
<i>221</i>&nbsp;		// A note on attributes:
<i>222</i>&nbsp;		// 1. The geometry with lower dimension wins in regard to the
<i>223</i>&nbsp;		// attributes.
<i>224</i>&nbsp;		// 2. If the dimensions are the same, the input_geometry attributes win.
<i>225</i>&nbsp;		// 3. The exception to the 2. is when the input is an Envelope, and the
<i>226</i>&nbsp;		// intersector is a polygon, then the intersector wins.
<i>227</i>&nbsp;
<i>228</i>&nbsp;		// A note on the tolerance:
<i>229</i>&nbsp;		// This operator performs a simple intersection operation. Should it use
<i>230</i>&nbsp;		// the tolerance?
<i>231</i>&nbsp;		// Example: Point is intersected by the envelope.
<i>232</i>&nbsp;		// If it is slightly outside of the envelope, should we still return it
<i>233</i>&nbsp;		// if it is closer than the tolerance?
<i>234</i>&nbsp;		// Should we do crack and cluster and snap the point coordinates to the
<i>235</i>&nbsp;		// envelope boundary?
<i>236</i>&nbsp;		//
<i>237</i>&nbsp;		// Consider floating point arithmetics approach. When you compare
<i>238</i>&nbsp;		// doubles, you should use an epsilon (equals means ::fabs(a - b) &lt;
<i>239</i>&nbsp;		// eps), however when you add/subtract, etc them, you do not use
<i>240</i>&nbsp;		// epsilon.
<i>241</i>&nbsp;		// Shouldn&#39;t we do same here? Relational operators use tolerance, but
<i>242</i>&nbsp;		// the action operators don&#39;t.
<i>243</i>&nbsp;
<b class="fc"><i>244</i>&nbsp;		Envelope2D mergedExtent = InternalUtils.getMergedExtent(input_geom,</b>
<i>245</i>&nbsp;				m_geomIntersector);
<b class="fc"><i>246</i>&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
<i>247</i>&nbsp;				m_spatial_reference, mergedExtent, false);
<i>248</i>&nbsp;
<b class="fc"><i>249</i>&nbsp;		int gtInput = input_geom.getType().value();</b>
<b class="fc"><i>250</i>&nbsp;		boolean bInputEmpty = input_geom.isEmpty();</b>
<b class="fc"><i>251</i>&nbsp;		boolean bGeomIntersectorEmpty = m_geomIntersector.isEmpty();</b>
<b class="fc"><i>252</i>&nbsp;		boolean bResultIsEmpty = bInputEmpty || bGeomIntersectorEmpty;</b>
<b class="fc"><i>253</i>&nbsp;		if (!bResultIsEmpty) {// test envelopes</b>
<b class="fc"><i>254</i>&nbsp;			Envelope2D env2D1 = new Envelope2D();</b>
<b class="fc"><i>255</i>&nbsp;			input_geom.queryEnvelope2D(env2D1);</b>
<b class="fc"><i>256</i>&nbsp;			Envelope2D env2D2 = new Envelope2D();</b>
<b class="fc"><i>257</i>&nbsp;			m_geomIntersector.queryEnvelope2D(env2D2);</b>
<b class="fc"><i>258</i>&nbsp;                        env2D2.inflate(2.0 * tolerance, 2.0 * tolerance);</b>
<b class="fc"><i>259</i>&nbsp;			bResultIsEmpty = !env2D1.isIntersecting(env2D2);</b>
<i>260</i>&nbsp;		}
<i>261</i>&nbsp;
<b class="fc"><i>262</i>&nbsp;		if (!bResultIsEmpty) {// try accelerated test</b>
<b class="fc"><i>263</i>&nbsp;			int res = OperatorInternalRelationUtils</b>
<b class="fc"><i>264</i>&nbsp;					.quickTest2D_Accelerated_DisjointOrContains(</b>
<i>265</i>&nbsp;							m_geomIntersector, input_geom, tolerance);
<b class="fc"><i>266</i>&nbsp;			if (res == OperatorInternalRelationUtils.Relation.Disjoint) {// disjoint</b>
<b class="nc"><i>267</i>&nbsp;				bResultIsEmpty = true;</b>
<b class="fc"><i>268</i>&nbsp;			} else if ((res &amp; OperatorInternalRelationUtils.Relation.Within) != 0) {// intersector</b>
<i>269</i>&nbsp;																					// is
<i>270</i>&nbsp;																					// within
<i>271</i>&nbsp;																					// the
<i>272</i>&nbsp;																					// input_geom
<i>273</i>&nbsp;																					// TODO:
<i>274</i>&nbsp;																					// assign
<i>275</i>&nbsp;																					// input_geom
<i>276</i>&nbsp;																					// attributes
<i>277</i>&nbsp;																					// first
<b class="nc"><i>278</i>&nbsp;				return m_geomIntersector;</b>
<b class="fc"><i>279</i>&nbsp;			} else if ((res &amp; OperatorInternalRelationUtils.Relation.Contains) != 0) {// intersector</b>
<i>280</i>&nbsp;																						// contains
<i>281</i>&nbsp;																						// input_geom
<b class="nc"><i>282</i>&nbsp;				return input_geom;</b>
<i>283</i>&nbsp;			}
<i>284</i>&nbsp;		}
<i>285</i>&nbsp;
<b class="fc"><i>286</i>&nbsp;		if (bResultIsEmpty) {// When one geometry or both are empty, we need to</b>
<i>287</i>&nbsp;								// return an empty geometry.
<i>288</i>&nbsp;								// Here we do that end also ensure the type is
<i>289</i>&nbsp;								// correct.
<i>290</i>&nbsp;								// That is the lower dimension need to be
<i>291</i>&nbsp;								// returned. Also, for Point vs Multi_point, an
<i>292</i>&nbsp;								// empty Point need to be returned.
<b class="fc"><i>293</i>&nbsp;			int dim1 = Geometry.getDimensionFromType(gtInput);</b>
<b class="fc"><i>294</i>&nbsp;			int dim2 = Geometry.getDimensionFromType(m_geomIntersectorType);</b>
<b class="fc"><i>295</i>&nbsp;			if (dim1 &lt; dim2)</b>
<b class="fc"><i>296</i>&nbsp;				return returnEmpty_(input_geom, bInputEmpty);</b>
<b class="fc"><i>297</i>&nbsp;			else if (dim1 &gt; dim2)</b>
<b class="nc"><i>298</i>&nbsp;				return returnEmptyIntersector_();</b>
<b class="fc"><i>299</i>&nbsp;			else if (dim1 == 0) {</b>
<b class="fc"><i>300</i>&nbsp;				if (gtInput == Geometry.GeometryType.MultiPoint</b>
<i>301</i>&nbsp;						&amp;&amp; m_geomIntersectorType == Geometry.GeometryType.Point) {// point
<i>302</i>&nbsp;																					// vs
<i>303</i>&nbsp;																					// Multi_point
<i>304</i>&nbsp;																					// need
<i>305</i>&nbsp;																					// special
<i>306</i>&nbsp;																					// treatment
<i>307</i>&nbsp;																					// to
<i>308</i>&nbsp;																					// ensure
<i>309</i>&nbsp;																					// Point
<i>310</i>&nbsp;																					// is
<i>311</i>&nbsp;																					// returned
<i>312</i>&nbsp;																					// always.
<b class="nc"><i>313</i>&nbsp;					return returnEmptyIntersector_();</b>
<i>314</i>&nbsp;				} else
<i>315</i>&nbsp;					// Both input and intersector have same gtype, or input is
<i>316</i>&nbsp;					// Point.
<b class="fc"><i>317</i>&nbsp;					return returnEmpty_(input_geom, bInputEmpty);</b>
<i>318</i>&nbsp;			} else
<b class="fc"><i>319</i>&nbsp;				return returnEmpty_(input_geom, bInputEmpty);</b>
<i>320</i>&nbsp;		}
<i>321</i>&nbsp;
<i>322</i>&nbsp;		// Note: No empty geometries after this point!
<i>323</i>&nbsp;
<i>324</i>&nbsp;		// Warning: Do not try clip for polylines and polygons.
<i>325</i>&nbsp;
<i>326</i>&nbsp;		// Try clip of Envelope with Envelope.
<b class="fc"><i>327</i>&nbsp;		if ((m_dimensionMask == -1 || m_dimensionMask == (1 &lt;&lt; 2))</b>
<i>328</i>&nbsp;				&amp;&amp; gtInput == Geometry.GeometryType.Envelope
<i>329</i>&nbsp;				&amp;&amp; m_geomIntersectorType == Geometry.GeometryType.Envelope) {
<b class="fc"><i>330</i>&nbsp;			Envelope env1 = (Envelope) input_geom;</b>
<b class="fc"><i>331</i>&nbsp;			Envelope env2 = (Envelope) m_geomIntersector;</b>
<b class="fc"><i>332</i>&nbsp;			Envelope2D env2D_1 = new Envelope2D();</b>
<b class="fc"><i>333</i>&nbsp;			env1.queryEnvelope2D(env2D_1);</b>
<b class="fc"><i>334</i>&nbsp;			Envelope2D env2D_2 = new Envelope2D();</b>
<b class="fc"><i>335</i>&nbsp;			env2.queryEnvelope2D(env2D_2);</b>
<b class="fc"><i>336</i>&nbsp;			env2D_1.intersect(env2D_2);</b>
<b class="fc"><i>337</i>&nbsp;			Envelope result_env = new Envelope();</b>
<b class="fc"><i>338</i>&nbsp;			env1.copyTo(result_env);</b>
<b class="fc"><i>339</i>&nbsp;			result_env.setEnvelope2D(env2D_1);</b>
<b class="fc"><i>340</i>&nbsp;			return result_env;</b>
<i>341</i>&nbsp;		}
<i>342</i>&nbsp;
<i>343</i>&nbsp;		// Use clip for Point and Multi_point with Envelope
<b class="fc"><i>344</i>&nbsp;		if ((gtInput == Geometry.GeometryType.Envelope &amp;&amp; Geometry</b>
<b class="nc"><i>345</i>&nbsp;				.getDimensionFromType(m_geomIntersectorType) == 0)</b>
<i>346</i>&nbsp;				|| (m_geomIntersectorType == Geometry.GeometryType.Envelope &amp;&amp; Geometry
<b class="fc"><i>347</i>&nbsp;						.getDimensionFromType(gtInput) == 0)) {</b>
<b class="fc"><i>348</i>&nbsp;			Envelope env = gtInput == Geometry.GeometryType.Envelope ? (Envelope) input_geom</b>
<i>349</i>&nbsp;					: (Envelope) m_geomIntersector;
<b class="fc"><i>350</i>&nbsp;			Geometry other = gtInput == Geometry.GeometryType.Envelope ? m_geomIntersector</b>
<i>351</i>&nbsp;					: input_geom;
<b class="fc"><i>352</i>&nbsp;			Envelope2D env_2D = new Envelope2D();</b>
<b class="fc"><i>353</i>&nbsp;			env.queryEnvelope2D(env_2D);</b>
<b class="fc"><i>354</i>&nbsp;			return Clipper.clip(other, env_2D, tolerance, 0);</b>
<i>355</i>&nbsp;		}
<i>356</i>&nbsp;
<b class="fc"><i>357</i>&nbsp;		if ((Geometry.getDimensionFromType(gtInput) == 0 &amp;&amp; Geometry</b>
<b class="fc"><i>358</i>&nbsp;				.getDimensionFromType(m_geomIntersectorType) &gt; 0)</b>
<b class="fc"><i>359</i>&nbsp;				|| (Geometry.getDimensionFromType(gtInput) &gt; 0 &amp;&amp; Geometry</b>
<b class="fc"><i>360</i>&nbsp;						.getDimensionFromType(m_geomIntersectorType) == 0)) {// multipoint</b>
<i>361</i>&nbsp;																				// intersection
<b class="fc"><i>362</i>&nbsp;			double tolerance1 = InternalUtils.calculateToleranceFromGeometry(</b>
<i>363</i>&nbsp;					m_spatial_reference, input_geom, false);
<b class="fc"><i>364</i>&nbsp;			if (gtInput == Geometry.GeometryType.MultiPoint)</b>
<b class="nc"><i>365</i>&nbsp;				return TopologicalOperations.intersection(</b>
<i>366</i>&nbsp;						(MultiPoint) input_geom, m_geomIntersector, tolerance1);
<b class="fc"><i>367</i>&nbsp;			if (gtInput == Geometry.GeometryType.Point)</b>
<b class="fc"><i>368</i>&nbsp;				return TopologicalOperations.intersection((Point) input_geom,</b>
<i>369</i>&nbsp;						m_geomIntersector, tolerance1);
<b class="fc"><i>370</i>&nbsp;			if (m_geomIntersectorType == Geometry.GeometryType.MultiPoint)</b>
<b class="fc"><i>371</i>&nbsp;				return TopologicalOperations.intersection(</b>
<i>372</i>&nbsp;						(MultiPoint) m_geomIntersector, input_geom, tolerance1);
<b class="fc"><i>373</i>&nbsp;			if (m_geomIntersectorType == Geometry.GeometryType.Point)</b>
<b class="fc"><i>374</i>&nbsp;				return TopologicalOperations.intersection(</b>
<i>375</i>&nbsp;						(Point) m_geomIntersector, input_geom, tolerance1);
<b class="nc"><i>376</i>&nbsp;			throw GeometryException.GeometryInternalError();</b>
<i>377</i>&nbsp;		}
<i>378</i>&nbsp;
<i>379</i>&nbsp;		// Try Polyline vs Polygon
<b class="fc"><i>380</i>&nbsp;		if ((m_dimensionMask == -1 || m_dimensionMask == (1 &lt;&lt; 1))</b>
<i>381</i>&nbsp;				&amp;&amp; (gtInput == Geometry.GeometryType.Polyline)
<i>382</i>&nbsp;				&amp;&amp; (m_geomIntersectorType == Geometry.GeometryType.Polygon)) {
<b class="fc"><i>383</i>&nbsp;			return tryFastIntersectPolylinePolygon_((Polyline) (input_geom),</b>
<i>384</i>&nbsp;					(Polygon) (m_geomIntersector));
<i>385</i>&nbsp;		}
<i>386</i>&nbsp;
<i>387</i>&nbsp;		// Try Polygon vs Polyline
<b class="fc"><i>388</i>&nbsp;		if ((m_dimensionMask == -1 || m_dimensionMask == (1 &lt;&lt; 1))</b>
<i>389</i>&nbsp;				&amp;&amp; (gtInput == Geometry.GeometryType.Polygon)
<i>390</i>&nbsp;				&amp;&amp; (m_geomIntersectorType == Geometry.GeometryType.Polyline)) {
<b class="fc"><i>391</i>&nbsp;			return tryFastIntersectPolylinePolygon_(</b>
<i>392</i>&nbsp;					(Polyline) (m_geomIntersector), (Polygon) (input_geom));
<i>393</i>&nbsp;		}
<i>394</i>&nbsp;
<b class="fc"><i>395</i>&nbsp;		return null;</b>
<i>396</i>&nbsp;	}
<i>397</i>&nbsp;
<i>398</i>&nbsp;	Geometry tryFastIntersectPolylinePolygon_(Polyline polyline, Polygon polygon) {
<b class="fc"><i>399</i>&nbsp;		MultiPathImpl polylineImpl = (MultiPathImpl) polyline._getImpl();</b>
<b class="fc"><i>400</i>&nbsp;		MultiPathImpl polygonImpl = (MultiPathImpl) polygon._getImpl();</b>
<i>401</i>&nbsp;
<b class="fc"><i>402</i>&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
<i>403</i>&nbsp;				m_spatial_reference, polygon, false);
<b class="fc"><i>404</i>&nbsp;		Envelope2D clipEnvelope = new Envelope2D();</b>
<i>405</i>&nbsp;		{
<b class="fc"><i>406</i>&nbsp;			polygonImpl.queryEnvelope2D(clipEnvelope);</b>
<b class="fc"><i>407</i>&nbsp;			Envelope2D env1 = new Envelope2D();</b>
<b class="fc"><i>408</i>&nbsp;			polylineImpl.queryEnvelope2D(env1);</b>
<b class="fc"><i>409</i>&nbsp;                        env1.inflate(2.0 * tolerance, 2.0 * tolerance);</b>
<b class="fc"><i>410</i>&nbsp;			clipEnvelope.intersect(env1);</b>
<b class="fc"><i>411</i>&nbsp;			assert (!clipEnvelope.isEmpty());</b>
<i>412</i>&nbsp;		}
<i>413</i>&nbsp;
<b class="fc"><i>414</i>&nbsp;		clipEnvelope.inflate(10 * tolerance, 10 * tolerance);</b>
<i>415</i>&nbsp;
<i>416</i>&nbsp;		if (true) {
<b class="fc"><i>417</i>&nbsp;			double tol = 0;</b>
<b class="fc"><i>418</i>&nbsp;			Geometry clippedPolyline = Clipper.clip(polyline, clipEnvelope,</b>
<i>419</i>&nbsp;					tol, 0.0);
<b class="fc"><i>420</i>&nbsp;			polyline = (Polyline) clippedPolyline;</b>
<b class="fc"><i>421</i>&nbsp;			polylineImpl = (MultiPathImpl) polyline._getImpl();</b>
<i>422</i>&nbsp;		}
<i>423</i>&nbsp;
<b class="fc"><i>424</i>&nbsp;		AttributeStreamOfInt32 clipResult = new AttributeStreamOfInt32(0);</b>
<b class="fc"><i>425</i>&nbsp;		int unresolvedSegments = -1;</b>
<b class="fc"><i>426</i>&nbsp;		GeometryAccelerators accel = polygonImpl._getAccelerators();</b>
<b class="fc"><i>427</i>&nbsp;		if (accel != null) {</b>
<b class="nc"><i>428</i>&nbsp;			RasterizedGeometry2D rgeom = accel.getRasterizedGeometry();</b>
<b class="nc"><i>429</i>&nbsp;			if (rgeom != null) {</b>
<b class="nc"><i>430</i>&nbsp;				unresolvedSegments = 0;</b>
<b class="nc"><i>431</i>&nbsp;				clipResult.reserve(polylineImpl.getPointCount()</b>
<b class="nc"><i>432</i>&nbsp;						+ polylineImpl.getPathCount());</b>
<b class="nc"><i>433</i>&nbsp;				Envelope2D seg_env = new Envelope2D();</b>
<b class="nc"><i>434</i>&nbsp;				SegmentIteratorImpl iter = polylineImpl.querySegmentIterator();</b>
<b class="nc"><i>435</i>&nbsp;				while (iter.nextPath()) {</b>
<b class="nc"><i>436</i>&nbsp;					while (iter.hasNextSegment()) {</b>
<b class="nc"><i>437</i>&nbsp;						Segment seg = iter.nextSegment();</b>
<b class="nc"><i>438</i>&nbsp;						seg.queryEnvelope2D(seg_env);</b>
<b class="nc"><i>439</i>&nbsp;						RasterizedGeometry2D.HitType hit = rgeom</b>
<b class="nc"><i>440</i>&nbsp;								.queryEnvelopeInGeometry(seg_env);</b>
<b class="nc"><i>441</i>&nbsp;						if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="nc"><i>442</i>&nbsp;							clipResult.add(1);</b>
<b class="nc"><i>443</i>&nbsp;						} else if (hit == RasterizedGeometry2D.HitType.Outside) {</b>
<b class="nc"><i>444</i>&nbsp;							clipResult.add(0);</b>
<i>445</i>&nbsp;						} else {
<b class="nc"><i>446</i>&nbsp;							clipResult.add(-1);</b>
<b class="nc"><i>447</i>&nbsp;							unresolvedSegments++;</b>
<i>448</i>&nbsp;						}
<b class="nc"><i>449</i>&nbsp;					}</b>
<i>450</i>&nbsp;				}
<i>451</i>&nbsp;			}
<i>452</i>&nbsp;		}
<i>453</i>&nbsp;
<b class="fc"><i>454</i>&nbsp;		if (polygon.getPointCount() &gt; 5) {</b>
<b class="fc"><i>455</i>&nbsp;			double tol = 0;</b>
<b class="fc"><i>456</i>&nbsp;			Geometry clippedPolygon = Clipper.clip(polygon, clipEnvelope, tol,</b>
<i>457</i>&nbsp;					0.0);
<i>458</i>&nbsp;
<b class="fc"><i>459</i>&nbsp;			polygon = (Polygon) clippedPolygon;</b>
<b class="fc"><i>460</i>&nbsp;			polygonImpl = (MultiPathImpl) polygon._getImpl();</b>
<b class="fc"><i>461</i>&nbsp;            accel = polygonImpl._getAccelerators();//update accelerators</b>
<i>462</i>&nbsp;		}
<i>463</i>&nbsp;
<b class="fc"><i>464</i>&nbsp;		if (unresolvedSegments &lt; 0) {</b>
<b class="fc"><i>465</i>&nbsp;			unresolvedSegments = polylineImpl.getSegmentCount();</b>
<i>466</i>&nbsp;		}
<i>467</i>&nbsp;
<i>468</i>&nbsp;		// Some heuristics to decide if it makes sense to go with fast intersect
<i>469</i>&nbsp;		// vs going with the regular planesweep.
<b class="fc"><i>470</i>&nbsp;		double totalPoints = (double) (polylineImpl.getPointCount() + polygonImpl</b>
<b class="fc"><i>471</i>&nbsp;				.getPointCount());</b>
<b class="fc"><i>472</i>&nbsp;		double thisAlgorithmComplexity = ((double) unresolvedSegments * polygonImpl</b>
<b class="fc"><i>473</i>&nbsp;				.getPointCount());// assume the worst case.</b>
<b class="fc"><i>474</i>&nbsp;		double planesweepComplexity = Math.log(totalPoints) * totalPoints;</b>
<b class="fc"><i>475</i>&nbsp;		double empiricConstantFactorPlaneSweep = 4;</b>
<b class="fc"><i>476</i>&nbsp;		if (thisAlgorithmComplexity &gt; planesweepComplexity</b>
<i>477</i>&nbsp;				* empiricConstantFactorPlaneSweep) {
<i>478</i>&nbsp;			// Based on the number of input points, we deduced that the
<i>479</i>&nbsp;			// plansweep performance should be better than the brute force
<i>480</i>&nbsp;			// performance.
<b class="nc"><i>481</i>&nbsp;			return null; // resort to planesweep if quadtree does not help</b>
<i>482</i>&nbsp;		}
<i>483</i>&nbsp;
<b class="fc"><i>484</i>&nbsp;		QuadTreeImpl polygonQuadTree = null;</b>
<b class="fc"><i>485</i>&nbsp;		SegmentIteratorImpl polygonIter = polygonImpl.querySegmentIterator();</b>
<i>486</i>&nbsp;		// Some logic to decide if it makes sense to build a quadtree on the
<i>487</i>&nbsp;		// polygon segments
<b class="fc"><i>488</i>&nbsp;		if (accel != null &amp;&amp; accel.getQuadTree() != null)</b>
<b class="nc"><i>489</i>&nbsp;			polygonQuadTree = accel.getQuadTree();</b>
<i>490</i>&nbsp;
<b class="fc"><i>491</i>&nbsp;		if (polygonQuadTree == null &amp;&amp; polygonImpl.getPointCount() &gt; 20) {</b>
<b class="nc"><i>492</i>&nbsp;			polygonQuadTree = InternalUtils.buildQuadTree(polygonImpl);</b>
<i>493</i>&nbsp;		}
<i>494</i>&nbsp;
<b class="fc"><i>495</i>&nbsp;		Polyline result_polyline = (Polyline) polyline.createInstance();</b>
<b class="fc"><i>496</i>&nbsp;		MultiPathImpl resultPolylineImpl = (MultiPathImpl) result_polyline</b>
<b class="fc"><i>497</i>&nbsp;				._getImpl();</b>
<b class="fc"><i>498</i>&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qIter = null;</b>
<b class="fc"><i>499</i>&nbsp;		SegmentIteratorImpl polylineIter = polylineImpl.querySegmentIterator();</b>
<b class="fc"><i>500</i>&nbsp;		double[] params = new double[9];</b>
<b class="fc"><i>501</i>&nbsp;		AttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);</b>
<b class="fc"><i>502</i>&nbsp;		SegmentBuffer segmentBuffer = new SegmentBuffer();</b>
<b class="fc"><i>503</i>&nbsp;		int start_index = -1;</b>
<b class="fc"><i>504</i>&nbsp;		int inCount = 0;</b>
<b class="fc"><i>505</i>&nbsp;		int segIndex = 0;</b>
<b class="fc"><i>506</i>&nbsp;		boolean bOptimized = clipResult.size() &gt; 0;</b>
<i>507</i>&nbsp;
<i>508</i>&nbsp;		// The algorithm is like that:
<i>509</i>&nbsp;		// Loop through all the segments of the polyline.
<i>510</i>&nbsp;		// For each polyline segment, intersect it with each of the polygon
<i>511</i>&nbsp;		// segments.
<i>512</i>&nbsp;		// If no intersections found then,
<i>513</i>&nbsp;		// If the polyline segment is completely inside, it is added to the
<i>514</i>&nbsp;		// result polyline.
<i>515</i>&nbsp;		// If it is outside, it is thrown out.
<i>516</i>&nbsp;		// If it intersects, then cut the polyline segment to pieces and test
<i>517</i>&nbsp;		// each part of the intersected result.
<i>518</i>&nbsp;		// The cut pieces will either have one point inside, or one point
<i>519</i>&nbsp;		// outside, or the middle point inside/outside.
<i>520</i>&nbsp;		//
<b class="fc"><i>521</i>&nbsp;		int polylinePathIndex = -1;</b>
<i>522</i>&nbsp;
<b class="fc"><i>523</i>&nbsp;		while (polylineIter.nextPath()) {</b>
<b class="fc"><i>524</i>&nbsp;			polylinePathIndex = polylineIter.getPathIndex();</b>
<b class="fc"><i>525</i>&nbsp;			int stateNewPath = 0;</b>
<b class="fc"><i>526</i>&nbsp;			int stateAddSegment = 1;</b>
<b class="fc"><i>527</i>&nbsp;			int stateManySegments = 2;</b>
<b class="fc"><i>528</i>&nbsp;			int stateManySegmentsContinuePath = 2;</b>
<b class="fc"><i>529</i>&nbsp;			int stateManySegmentsNewPath = 3;</b>
<b class="fc"><i>530</i>&nbsp;			int state = stateNewPath;</b>
<b class="fc"><i>531</i>&nbsp;			start_index = -1;</b>
<b class="fc"><i>532</i>&nbsp;			inCount = 0;</b>
<i>533</i>&nbsp;
<b class="fc"><i>534</i>&nbsp;			while (polylineIter.hasNextSegment()) {</b>
<b class="fc"><i>535</i>&nbsp;				int clipStatus = bOptimized ? (int) clipResult.get(segIndex)</b>
<i>536</i>&nbsp;						: -1;
<b class="fc"><i>537</i>&nbsp;				segIndex++;</b>
<b class="fc"><i>538</i>&nbsp;				Segment polylineSeg = polylineIter.nextSegment();</b>
<b class="fc"><i>539</i>&nbsp;				if (clipStatus &lt; 0) {</b>
<b class="fc"><i>540</i>&nbsp;					assert (clipStatus == -1);</b>
<i>541</i>&nbsp;					// Analyse polyline segment for intersection with the
<i>542</i>&nbsp;					// polygon.
<b class="fc"><i>543</i>&nbsp;					if (polygonQuadTree != null) {</b>
<b class="nc"><i>544</i>&nbsp;						if (qIter == null) {</b>
<b class="nc"><i>545</i>&nbsp;							qIter = polygonQuadTree.getIterator(polylineSeg,</b>
<i>546</i>&nbsp;									tolerance);
<i>547</i>&nbsp;						} else {
<b class="nc"><i>548</i>&nbsp;							qIter.resetIterator(polylineSeg, tolerance);</b>
<i>549</i>&nbsp;						}
<i>550</i>&nbsp;
<b class="nc"><i>551</i>&nbsp;						int path_index = -1;</b>
<b class="nc"><i>552</i>&nbsp;						for (int ind = qIter.next(); ind != -1; ind = qIter</b>
<b class="nc"><i>553</i>&nbsp;								.next()) {</b>
<b class="nc"><i>554</i>&nbsp;							polygonIter.resetToVertex(polygonQuadTree</b>
<b class="nc"><i>555</i>&nbsp;									.getElement(ind)); // path_index</b>
<b class="nc"><i>556</i>&nbsp;							path_index = polygonIter.getPathIndex();</b>
<b class="nc"><i>557</i>&nbsp;							Segment polygonSeg = polygonIter.nextSegment();</b>
<i>558</i>&nbsp;							// intersect polylineSeg and polygonSeg.
<b class="nc"><i>559</i>&nbsp;							int count = polylineSeg.intersect(polygonSeg, null,</b>
<i>560</i>&nbsp;									params, null, tolerance);
<b class="nc"><i>561</i>&nbsp;							for (int i = 0; i &lt; count; i++)</b>
<b class="nc"><i>562</i>&nbsp;								intersections.add(params[i]);</b>
<i>563</i>&nbsp;						}
<b class="nc"><i>564</i>&nbsp;					} else {// no quadtree built</b>
<b class="fc"><i>565</i>&nbsp;						polygonIter.resetToFirstPath();</b>
<b class="fc"><i>566</i>&nbsp;						while (polygonIter.nextPath()) {</b>
<b class="fc"><i>567</i>&nbsp;							while (polygonIter.hasNextSegment()) {</b>
<b class="fc"><i>568</i>&nbsp;								Segment polygonSeg = polygonIter.nextSegment();</b>
<i>569</i>&nbsp;								// intersect polylineSeg and polygonSeg.
<b class="fc"><i>570</i>&nbsp;								int count = polylineSeg.intersect(polygonSeg,</b>
<i>571</i>&nbsp;										null, params, null, tolerance);
<b class="fc"><i>572</i>&nbsp;								for (int i = 0; i &lt; count; i++)</b>
<b class="fc"><i>573</i>&nbsp;									intersections.add(params[i]);</b>
<b class="fc"><i>574</i>&nbsp;							}</b>
<i>575</i>&nbsp;						}
<i>576</i>&nbsp;					}
<i>577</i>&nbsp;
<b class="fc"><i>578</i>&nbsp;					if (intersections.size() &gt; 0) {// intersections detected.</b>
<b class="fc"><i>579</i>&nbsp;						intersections.sort(0, intersections.size()); // std::sort(intersections.begin(),</b>
<i>580</i>&nbsp;																		// intersections.end());
<i>581</i>&nbsp;
<b class="fc"><i>582</i>&nbsp;						double t0 = 0;</b>
<b class="fc"><i>583</i>&nbsp;						intersections.add(1.0);</b>
<b class="fc"><i>584</i>&nbsp;						int status = -1;</b>
<b class="fc"><i>585</i>&nbsp;						for (int i = 0, n = intersections.size(); i &lt; n; i++) {</b>
<b class="fc"><i>586</i>&nbsp;							double t = intersections.get(i);</b>
<b class="fc"><i>587</i>&nbsp;							if (t == t0) {</b>
<b class="fc"><i>588</i>&nbsp;								continue;</b>
<i>589</i>&nbsp;							}
<b class="fc"><i>590</i>&nbsp;							boolean bWholeSegment = false;</b>
<i>591</i>&nbsp;							Segment resSeg;
<b class="fc"><i>592</i>&nbsp;							if (t0 != 0 || t != 1.0) {</b>
<b class="fc"><i>593</i>&nbsp;								polylineSeg.cut(t0, t, segmentBuffer);</b>
<b class="fc"><i>594</i>&nbsp;								resSeg = segmentBuffer.get();</b>
<i>595</i>&nbsp;							} else {
<b class="fc"><i>596</i>&nbsp;								resSeg = polylineSeg;</b>
<b class="fc"><i>597</i>&nbsp;								bWholeSegment = true;</b>
<i>598</i>&nbsp;							}
<i>599</i>&nbsp;
<b class="fc"><i>600</i>&nbsp;							if (state &gt;= stateManySegments) {</b>
<b class="fc"><i>601</i>&nbsp;								resultPolylineImpl.addSegmentsFromPath(</b>
<i>602</i>&nbsp;										polylineImpl, polylinePathIndex,
<i>603</i>&nbsp;										start_index, inCount,
<i>604</i>&nbsp;										state == stateManySegmentsNewPath);
<b class="fc"><i>605</i>&nbsp;								if (analyseClipSegment_(polygon,</b>
<b class="fc"><i>606</i>&nbsp;										resSeg.getStartXY(), tolerance) != 1) {</b>
<b class="fc"><i>607</i>&nbsp;									if (analyseClipSegment_(polygon, resSeg,</b>
<i>608</i>&nbsp;											tolerance) != 1) {
<b class="nc"><i>609</i>&nbsp;										return null;  //someting went wrong we&#39;ll falback to slower but robust planesweep code.</b>
<i>610</i>&nbsp;									}
<i>611</i>&nbsp;								}
<i>612</i>&nbsp;
<b class="fc"><i>613</i>&nbsp;								resultPolylineImpl.addSegment(resSeg, false);</b>
<b class="fc"><i>614</i>&nbsp;								state = stateAddSegment;</b>
<b class="fc"><i>615</i>&nbsp;								inCount = 0;</b>
<i>616</i>&nbsp;							} else {
<b class="fc"><i>617</i>&nbsp;								status = analyseClipSegment_(polygon, resSeg,</b>
<i>618</i>&nbsp;										tolerance);
<b class="fc"><i>619</i>&nbsp;								switch (status) {</b>
<i>620</i>&nbsp;								case 1:
<b class="fc"><i>621</i>&nbsp;									if (!bWholeSegment) {</b>
<b class="fc"><i>622</i>&nbsp;										resultPolylineImpl.addSegment(resSeg,</b>
<i>623</i>&nbsp;												state == stateNewPath);
<b class="fc"><i>624</i>&nbsp;										state = stateAddSegment;</b>
<i>625</i>&nbsp;									} else {
<b class="fc"><i>626</i>&nbsp;										if (state &lt; stateManySegments) {</b>
<b class="fc"><i>627</i>&nbsp;											start_index = polylineIter</b>
<b class="fc"><i>628</i>&nbsp;													.getStartPointIndex()</b>
<i>629</i>&nbsp;													- polylineImpl
<b class="fc"><i>630</i>&nbsp;															.getPathStart(polylinePathIndex);</b>
<b class="fc"><i>631</i>&nbsp;											inCount = 1;</b>
<i>632</i>&nbsp;
<b class="fc"><i>633</i>&nbsp;											if (state == stateNewPath)</b>
<b class="fc"><i>634</i>&nbsp;												state = stateManySegmentsNewPath;</b>
<i>635</i>&nbsp;											else {
<b class="nc"><i>636</i>&nbsp;												assert (state == stateAddSegment);</b>
<b class="nc"><i>637</i>&nbsp;												state = stateManySegmentsContinuePath;</b>
<i>638</i>&nbsp;											}
<i>639</i>&nbsp;										} else
<b class="nc"><i>640</i>&nbsp;											inCount++;</b>
<i>641</i>&nbsp;									}
<i>642</i>&nbsp;
<b class="nc"><i>643</i>&nbsp;									break;</b>
<i>644</i>&nbsp;								case 0:
<b class="fc"><i>645</i>&nbsp;									state = stateNewPath;</b>
<b class="fc"><i>646</i>&nbsp;									start_index = -1;</b>
<b class="fc"><i>647</i>&nbsp;									inCount = 0;</b>
<b class="fc"><i>648</i>&nbsp;									break;</b>
<i>649</i>&nbsp;								default:
<b class="fc"><i>650</i>&nbsp;									return null;// may happen if a segment</b>
<i>651</i>&nbsp;												// coincides with the border.
<i>652</i>&nbsp;								}
<i>653</i>&nbsp;							}
<i>654</i>&nbsp;
<b class="fc"><i>655</i>&nbsp;							t0 = t;</b>
<i>656</i>&nbsp;						}
<b class="fc"><i>657</i>&nbsp;					} else {</b>
<b class="fc"><i>658</i>&nbsp;						clipStatus = analyseClipSegment_(polygon,</b>
<b class="fc"><i>659</i>&nbsp;								polylineSeg.getStartXY(), tolerance);// simple</b>
<i>660</i>&nbsp;																		// case
<i>661</i>&nbsp;																		// no
<i>662</i>&nbsp;																		// intersection.
<i>663</i>&nbsp;																		// Both
<i>664</i>&nbsp;																		// points
<i>665</i>&nbsp;																		// must
<i>666</i>&nbsp;																		// be
<i>667</i>&nbsp;																		// inside.
<b class="fc"><i>668</i>&nbsp;						if (clipStatus &lt; 0) {</b>
<b class="nc"><i>669</i>&nbsp;							assert (clipStatus &gt;= 0);</b>
<b class="nc"><i>670</i>&nbsp;							return null;// something goes wrong, resort to</b>
<i>671</i>&nbsp;										// planesweep
<i>672</i>&nbsp;						}
<i>673</i>&nbsp;
<b class="fc"><i>674</i>&nbsp;						assert (analyseClipSegment_(polygon,</b>
<b class="fc"><i>675</i>&nbsp;								polylineSeg.getEndXY(), tolerance) == clipStatus);</b>
<b class="fc"><i>676</i>&nbsp;						if (clipStatus == 1) {// the whole segment inside</b>
<b class="fc"><i>677</i>&nbsp;							if (state &lt; stateManySegments) {</b>
<b class="fc"><i>678</i>&nbsp;								assert (inCount == 0);</b>
<b class="fc"><i>679</i>&nbsp;								start_index = polylineIter.getStartPointIndex()</b>
<i>680</i>&nbsp;										- polylineImpl
<b class="fc"><i>681</i>&nbsp;												.getPathStart(polylinePathIndex);</b>
<b class="fc"><i>682</i>&nbsp;								if (state == stateNewPath)</b>
<b class="fc"><i>683</i>&nbsp;									state = stateManySegmentsNewPath;</b>
<i>684</i>&nbsp;								else {
<b class="fc"><i>685</i>&nbsp;									assert (state == stateAddSegment);</b>
<b class="fc"><i>686</i>&nbsp;									state = stateManySegmentsContinuePath;</b>
<i>687</i>&nbsp;								}
<i>688</i>&nbsp;							}
<i>689</i>&nbsp;
<b class="fc"><i>690</i>&nbsp;							inCount++;</b>
<i>691</i>&nbsp;						} else {
<b class="fc"><i>692</i>&nbsp;							assert (state &lt; stateManySegments);</b>
<b class="fc"><i>693</i>&nbsp;							start_index = -1;</b>
<b class="fc"><i>694</i>&nbsp;							inCount = 0;</b>
<i>695</i>&nbsp;						}
<i>696</i>&nbsp;					}
<i>697</i>&nbsp;
<b class="fc"><i>698</i>&nbsp;					intersections.clear(false);</b>
<i>699</i>&nbsp;				} else {// clip status is determined by other means
<b class="nc"><i>700</i>&nbsp;					if (clipStatus == 0) {// outside</b>
<b class="nc"><i>701</i>&nbsp;						assert (analyseClipSegment_(polygon, polylineSeg,</b>
<i>702</i>&nbsp;								tolerance) == 0);
<b class="nc"><i>703</i>&nbsp;						assert (start_index &lt; 0);</b>
<b class="nc"><i>704</i>&nbsp;						assert (inCount == 0);</b>
<i>705</i>&nbsp;						continue;
<i>706</i>&nbsp;					}
<i>707</i>&nbsp;
<b class="nc"><i>708</i>&nbsp;					if (clipStatus == 1) {</b>
<b class="nc"><i>709</i>&nbsp;						assert (analyseClipSegment_(polygon, polylineSeg,</b>
<i>710</i>&nbsp;								tolerance) == 1);
<b class="nc"><i>711</i>&nbsp;						if (state == stateNewPath) {</b>
<b class="nc"><i>712</i>&nbsp;							state = stateManySegmentsNewPath;</b>
<b class="nc"><i>713</i>&nbsp;							start_index = polylineIter.getStartPointIndex()</b>
<i>714</i>&nbsp;									- polylineImpl
<b class="nc"><i>715</i>&nbsp;											.getPathStart(polylinePathIndex);</b>
<b class="nc"><i>716</i>&nbsp;						} else if (state == stateAddSegment) {</b>
<b class="nc"><i>717</i>&nbsp;							state = stateManySegmentsContinuePath;</b>
<b class="nc"><i>718</i>&nbsp;							start_index = polylineIter.getStartPointIndex()</b>
<i>719</i>&nbsp;									- polylineImpl
<b class="nc"><i>720</i>&nbsp;											.getPathStart(polylinePathIndex);</b>
<i>721</i>&nbsp;						} else
<b class="nc"><i>722</i>&nbsp;							assert (state &gt;= stateManySegments);</b>
<i>723</i>&nbsp;
<b class="nc"><i>724</i>&nbsp;						inCount++;</b>
<b class="nc"><i>725</i>&nbsp;						continue;</b>
<i>726</i>&nbsp;					}
<i>727</i>&nbsp;				}
<b class="fc"><i>728</i>&nbsp;			}</b>
<i>729</i>&nbsp;
<b class="fc"><i>730</i>&nbsp;			if (state &gt;= stateManySegments) {</b>
<b class="fc"><i>731</i>&nbsp;				resultPolylineImpl.addSegmentsFromPath(polylineImpl,</b>
<i>732</i>&nbsp;						polylinePathIndex, start_index, inCount,
<i>733</i>&nbsp;						state == stateManySegmentsNewPath);
<b class="fc"><i>734</i>&nbsp;				start_index = -1;</b>
<i>735</i>&nbsp;			}
<b class="fc"><i>736</i>&nbsp;		}</b>
<i>737</i>&nbsp;
<b class="fc"><i>738</i>&nbsp;		return result_polyline;</b>
<i>739</i>&nbsp;	}
<i>740</i>&nbsp;
<i>741</i>&nbsp;	int analyseClipSegment_(Polygon polygon, Point2D pt, double tol) {
<b class="fc"><i>742</i>&nbsp;		int v = PointInPolygonHelper.isPointInPolygon(polygon, pt, tol);</b>
<b class="fc"><i>743</i>&nbsp;		return v;</b>
<i>744</i>&nbsp;	}
<i>745</i>&nbsp;
<i>746</i>&nbsp;	int analyseClipSegment_(Polygon polygon, Segment seg, double tol) {
<b class="fc"><i>747</i>&nbsp;		Point2D pt_1 = seg.getStartXY();</b>
<b class="fc"><i>748</i>&nbsp;		Point2D pt_2 = seg.getEndXY();</b>
<b class="fc"><i>749</i>&nbsp;		int v_1 = PointInPolygonHelper.isPointInPolygon(polygon, pt_1, tol);</b>
<b class="fc"><i>750</i>&nbsp;		int v_2 = PointInPolygonHelper.isPointInPolygon(polygon, pt_2, tol);</b>
<b class="fc"><i>751</i>&nbsp;		if ((v_1 == 1 &amp;&amp; v_2 == 0) || (v_1 == 0 &amp;&amp; v_2 == 1)) {</b>
<i>752</i>&nbsp;			// Operator_factory_local::SaveJSONToTextFileDbg(&quot;c:/temp/badPointInPolygon.json&quot;,
<i>753</i>&nbsp;			// polygon, m_spatial_reference);
<b class="nc"><i>754</i>&nbsp;			assert (false);// if happens</b>
<b class="nc"><i>755</i>&nbsp;			return -1;// something went wrong. One point is inside, the other is</b>
<i>756</i>&nbsp;						// outside. Should not happen. We&#39;ll resort to
<i>757</i>&nbsp;						// planesweep.
<i>758</i>&nbsp;		}
<b class="fc"><i>759</i>&nbsp;		if (v_1 == 0 || v_2 == 0)</b>
<b class="fc"><i>760</i>&nbsp;			return 0;</b>
<b class="fc"><i>761</i>&nbsp;		if (v_1 == 1 || v_2 == 1)</b>
<b class="fc"><i>762</i>&nbsp;			return 1;</b>
<i>763</i>&nbsp;
<b class="fc"><i>764</i>&nbsp;		Point2D midPt = new Point2D();</b>
<b class="fc"><i>765</i>&nbsp;		midPt.add(pt_1, pt_2);</b>
<b class="fc"><i>766</i>&nbsp;		midPt.scale(0.5);// calculate midpoint</b>
<b class="fc"><i>767</i>&nbsp;		int v = PointInPolygonHelper.isPointInPolygon(polygon, midPt, tol);</b>
<b class="fc"><i>768</i>&nbsp;		if (v == 0) {</b>
<b class="fc"><i>769</i>&nbsp;			return 0;</b>
<i>770</i>&nbsp;		}
<i>771</i>&nbsp;
<b class="fc"><i>772</i>&nbsp;		if (v == 1) {</b>
<b class="fc"><i>773</i>&nbsp;			return 1;</b>
<i>774</i>&nbsp;		}
<i>775</i>&nbsp;
<b class="fc"><i>776</i>&nbsp;		return -1;</b>
<i>777</i>&nbsp;	}
<i>778</i>&nbsp;
<i>779</i>&nbsp;	Geometry normalizeIntersectionOutput(Geometry geom, int GT_1, int GT_2) {
<b class="nc"><i>780</i>&nbsp;		if (GT_1 == Geometry.GeometryType.Point</b>
<i>781</i>&nbsp;				|| GT_2 == Geometry.GeometryType.Point) {
<b class="nc"><i>782</i>&nbsp;			assert (geom.getType().value() == Geometry.GeometryType.Point);</b>
<i>783</i>&nbsp;		}
<b class="nc"><i>784</i>&nbsp;		if (GT_1 == Geometry.GeometryType.MultiPoint) {</b>
<b class="nc"><i>785</i>&nbsp;			if (geom.getType().value() == Geometry.GeometryType.Point) {</b>
<b class="nc"><i>786</i>&nbsp;				MultiPoint mp = new MultiPoint(geom.getDescription());</b>
<b class="nc"><i>787</i>&nbsp;				if (!geom.isEmpty())</b>
<b class="nc"><i>788</i>&nbsp;					mp.add((Point) geom);</b>
<b class="nc"><i>789</i>&nbsp;				return mp;</b>
<i>790</i>&nbsp;			}
<i>791</i>&nbsp;		}
<i>792</i>&nbsp;
<b class="nc"><i>793</i>&nbsp;		return geom;</b>
<i>794</i>&nbsp;	}
<i>795</i>&nbsp;
<i>796</i>&nbsp;	static Geometry returnEmpty_(Geometry geom, boolean bEmpty) {
<b class="fc"><i>797</i>&nbsp;		return bEmpty ? geom : geom.createInstance();</b>
<i>798</i>&nbsp;	}
<i>799</i>&nbsp;
<i>800</i>&nbsp;	Geometry returnEmptyIntersector_() {
<b class="nc"><i>801</i>&nbsp;		if (m_geomIntersectorEmptyGeom == null)</b>
<b class="nc"><i>802</i>&nbsp;			m_geomIntersectorEmptyGeom = m_geomIntersector.createInstance();</b>
<i>803</i>&nbsp;
<b class="nc"><i>804</i>&nbsp;		return m_geomIntersectorEmptyGeom;</b>
<i>805</i>&nbsp;	}
<i>806</i>&nbsp;
<i>807</i>&nbsp;	// virtual boolean IsRecycling() OVERRIDE { return false; }
<i>808</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-02-26 10:02</div>
</div>
</body>
</html>
