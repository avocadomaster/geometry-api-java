


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: GeoDist</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.esri.core.geometry</a> ]
</div>

<h1>Coverage Summary for Class: GeoDist (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GeoDist</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.8%
  </span>
  <span class="absValue">
    (186/ 222)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; Copyright 1995-2015 Esri
<i>3</i>&nbsp;
<i>4</i>&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i>5</i>&nbsp;   you may not use this file except in compliance with the License.
<i>6</i>&nbsp;   You may obtain a copy of the License at
<i>7</i>&nbsp;
<i>8</i>&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp;
<i>10</i>&nbsp;   Unless required by applicable law or agreed to in writing, software
<i>11</i>&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>12</i>&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>13</i>&nbsp;   See the License for the specific language governing permissions and
<i>14</i>&nbsp;   limitations under the License.
<i>15</i>&nbsp;
<i>16</i>&nbsp; For additional information, contact:
<i>17</i>&nbsp; Environmental Systems Research Institute, Inc.
<i>18</i>&nbsp; Attn: Contracts Dept
<i>19</i>&nbsp; 380 New York Street
<i>20</i>&nbsp; Redlands, California, USA 92373
<i>21</i>&nbsp;
<i>22</i>&nbsp; email: contracts@esri.com
<i>23</i>&nbsp; */
<i>24</i>&nbsp;
<i>25</i>&nbsp;package com.esri.core.geometry;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import com.esri.core.geometry.PeDouble;
<i>28</i>&nbsp;
<b class="nc"><i>29</i>&nbsp;final class GeoDist {</b>
<i>30</i>&nbsp;	private static final double PE_PI = 3.14159265358979323846264;
<i>31</i>&nbsp;	private static final double PE_PI2 = 1.57079632679489661923132;
<i>32</i>&nbsp;	private static final double PE_2PI = 6.283185307179586476925287;
<i>33</i>&nbsp;	private static final double PE_EPS = 3.55271367880050092935562e-15;
<i>34</i>&nbsp;
<i>35</i>&nbsp;	/** Get the absolute value of a number */
<i>36</i>&nbsp;	static private double PE_ABS(double a) {
<b class="fc"><i>37</i>&nbsp;		return (a &lt; 0) ? -a : a;</b>
<i>38</i>&nbsp;	}
<i>39</i>&nbsp;
<i>40</i>&nbsp;	/** Assign the sign of the second number to the first */
<i>41</i>&nbsp;	static private double PE_SGN(double a, double b) {
<b class="fc"><i>42</i>&nbsp;		return (b &gt;= 0) ? PE_ABS(a) : -PE_ABS(a);</b>
<i>43</i>&nbsp;	}
<i>44</i>&nbsp;
<i>45</i>&nbsp;	/** Determine if two doubles are equal within a default tolerance */
<i>46</i>&nbsp;	static private boolean PE_EQ(double a, double b) {
<b class="fc"><i>47</i>&nbsp;		return (a == b)</b>
<b class="fc"><i>48</i>&nbsp;				|| PE_ABS(a - b) &lt;= PE_EPS * (1 + (PE_ABS(a) + PE_ABS(b)) / 2);</b>
<i>49</i>&nbsp;	}
<i>50</i>&nbsp;
<i>51</i>&nbsp;	/** Determine if a double is within a given tolerance of zero */
<i>52</i>&nbsp;	static private boolean PE_ZERO(double a) {
<b class="fc"><i>53</i>&nbsp;		return (a == 0.0) || (PE_ABS(a) &lt;= PE_EPS);</b>
<i>54</i>&nbsp;	}
<i>55</i>&nbsp;
<i>56</i>&nbsp;	static private double lam_delta(double lam) {
<b class="fc"><i>57</i>&nbsp;		double d = Math.IEEEremainder(lam, PE_2PI);</b>
<i>58</i>&nbsp;
<b class="fc"><i>59</i>&nbsp;		return (PE_ABS(d) &lt;= PE_PI) ? d : ((d &lt; 0) ? d + PE_2PI : d - PE_2PI);</b>
<i>60</i>&nbsp;	}
<i>61</i>&nbsp;
<i>62</i>&nbsp;	static private void lam_phi_reduction(PeDouble p_lam, PeDouble p_phi) {
<b class="fc"><i>63</i>&nbsp;		p_lam.val = lam_delta(p_lam.val);</b>
<b class="fc"><i>64</i>&nbsp;		p_phi.val = lam_delta(p_phi.val);</b>
<i>65</i>&nbsp;
<b class="fc"><i>66</i>&nbsp;		if (PE_ABS(p_phi.val) &gt; PE_PI2) {</b>
<b class="nc"><i>67</i>&nbsp;			p_lam.val = lam_delta(p_lam.val + PE_PI);</b>
<b class="nc"><i>68</i>&nbsp;			p_phi.val = PE_SGN(PE_PI, p_phi.val) - p_phi.val;</b>
<i>69</i>&nbsp;		}
<b class="fc"><i>70</i>&nbsp;	}</b>
<i>71</i>&nbsp;
<i>72</i>&nbsp;	static private double q90(double a, double e2) {
<i>73</i>&nbsp;		/*
<i>74</i>&nbsp;		 * Rapp // Geometric Geodesy (Part I) // p. 39. Adams, O.S. // Latitude
<i>75</i>&nbsp;		 * Developments ... // pp. 122-127. Terms extended past n4 by David
<i>76</i>&nbsp;		 * Burrows, ESRI
<i>77</i>&nbsp;		 */
<i>78</i>&nbsp;
<i>79</i>&nbsp;		/* Calculate meridional arc distance from equator to pole */
<i>80</i>&nbsp;
<i>81</i>&nbsp;		/*
<i>82</i>&nbsp;		 * q90 = a * PE_PI2 * (1 + 1/4 n2 + 1/64 n4 + 1/256 n6 + 25/16384 n8 +
<i>83</i>&nbsp;		 * 49/65536 n10 + ...)/(1.0 + n)
<i>84</i>&nbsp;		 */
<i>85</i>&nbsp;
<b class="fc"><i>86</i>&nbsp;		double t = Math.sqrt(1.0 - e2);</b>
<b class="fc"><i>87</i>&nbsp;		double n = (1.0 - t) / (1.0 + t);</b>
<b class="fc"><i>88</i>&nbsp;		double n2 = n * n;</b>
<i>89</i>&nbsp;
<b class="fc"><i>90</i>&nbsp;		return a / (1.0 + n)</b>
<i>91</i>&nbsp;				* (1.0 + n2 * (1.0 / 4.0 + n2 * (1.0 / 64.0 + n2 * (1.0 / 256.0))))
<i>92</i>&nbsp;				* PE_PI2;
<i>93</i>&nbsp;	}
<i>94</i>&nbsp;
<i>95</i>&nbsp;	static public void geodesic_distance_ngs(double a, double e2, double lam1,
<i>96</i>&nbsp;			double phi1, double lam2, double phi2, PeDouble p_dist,
<i>97</i>&nbsp;			PeDouble p_az12, PeDouble p_az21) {
<i>98</i>&nbsp;		/* Highly edited version (plus lots of additions) of NGS FORTRAN code */
<i>99</i>&nbsp;
<i>100</i>&nbsp;		/*
<i>101</i>&nbsp;		 * inverse for long-line and antipodal cases.* latitudes may be 90
<i>102</i>&nbsp;		 * degrees exactly.* latitude positive north, longitude positive east,
<i>103</i>&nbsp;		 * radians.* azimuth clockwise from north, radians.* original programmed
<i>104</i>&nbsp;		 * by thaddeus vincenty, 1975, 1976* removed back side solution option,
<i>105</i>&nbsp;		 * debugged, revised -- 2011may01 -- dgm* this version of code is
<i>106</i>&nbsp;		 * interim -- antipodal boundary needs work
<i>107</i>&nbsp;		 * 
<i>108</i>&nbsp;		 * * output (besides az12, az21, and dist):* These have been removed
<i>109</i>&nbsp;		 * from this esri version of the ngs code* it, iteration count* sigma,
<i>110</i>&nbsp;		 * spherical distance on auxiliary sphere* lam_sph, longitude difference
<i>111</i>&nbsp;		 * on auxiliary sphere* kind, solution flag: kind=1, long-line; kind=2,
<i>112</i>&nbsp;		 * antipodal
<i>113</i>&nbsp;		 * 
<i>114</i>&nbsp;		 * 
<i>115</i>&nbsp;		 * All references to Rapp are Part II
<i>116</i>&nbsp;		 */
<i>117</i>&nbsp;
<b class="fc"><i>118</i>&nbsp;		double tol = 1.0e-14;</b>
<b class="fc"><i>119</i>&nbsp;		double eps = 1.0e-15;</b>
<i>120</i>&nbsp;
<b class="fc"><i>121</i>&nbsp;		double boa = 0.0;</b>
<b class="fc"><i>122</i>&nbsp;		double dlam = 0.0;</b>
<b class="fc"><i>123</i>&nbsp;		double eta1 = 0.0, sin_eta1 = 0.0, cos_eta1 = 0.0;</b>
<b class="fc"><i>124</i>&nbsp;		double eta2 = 0.0, sin_eta2 = 0.0, cos_eta2 = 0.0;</b>
<b class="fc"><i>125</i>&nbsp;		double prev = 0.0, test = 0.0;</b>
<b class="fc"><i>126</i>&nbsp;		double sin_lam_sph = 0.0, cos_lam_sph = 0.0, temp = 0.0, sin_sigma = 0.0, cos_sigma = 0.0;</b>
<b class="fc"><i>127</i>&nbsp;		double sin_azeq = 0.0, cos2_azeq = 0.0, costm = 0.0, costm2 = 0.0, c = 0.0, d = 0.0;</b>
<b class="fc"><i>128</i>&nbsp;		double tem1 = 0.0, tem2 = 0.0, ep2 = 0.0, bige = 0.0, bigf = 0.0, biga = 0.0, bigb = 0.0, z = 0.0, dsigma = 0.0;</b>
<i>129</i>&nbsp;		boolean q_continue_looping;
<i>130</i>&nbsp;
<b class="fc"><i>131</i>&nbsp;		double f = 0.0;</b>
<i>132</i>&nbsp;
<b class="fc"><i>133</i>&nbsp;		double az12 = 0.0, az21 = 0.0, dist = 0.0;</b>
<b class="fc"><i>134</i>&nbsp;		double sigma = 0.0, lam_sph = 0.0;</b>
<b class="fc"><i>135</i>&nbsp;		int it = 0, kind = 0;</b>
<i>136</i>&nbsp;
<b class="fc"><i>137</i>&nbsp;		PeDouble lam = new PeDouble();</b>
<b class="fc"><i>138</i>&nbsp;		PeDouble phi = new PeDouble();</b>
<i>139</i>&nbsp;
<i>140</i>&nbsp;		/* Are there any values to calculate? */
<b class="fc"><i>141</i>&nbsp;		if (p_dist == null &amp;&amp; p_az12 == null &amp;&amp; p_az21 == null) {</b>
<b class="nc"><i>142</i>&nbsp;			return;</b>
<i>143</i>&nbsp;		}
<i>144</i>&nbsp;
<i>145</i>&nbsp;		/* Normalize point 1 and 2 */
<b class="fc"><i>146</i>&nbsp;		lam.val = lam1;</b>
<b class="fc"><i>147</i>&nbsp;		phi.val = phi1;</b>
<b class="fc"><i>148</i>&nbsp;		lam_phi_reduction(lam, phi);</b>
<b class="fc"><i>149</i>&nbsp;		lam1 = lam.val;</b>
<b class="fc"><i>150</i>&nbsp;		phi1 = phi.val;</b>
<i>151</i>&nbsp;
<b class="fc"><i>152</i>&nbsp;		lam.val = lam2;</b>
<b class="fc"><i>153</i>&nbsp;		phi.val = phi2;</b>
<b class="fc"><i>154</i>&nbsp;		lam_phi_reduction(lam, phi);</b>
<b class="fc"><i>155</i>&nbsp;		lam2 = lam.val;</b>
<b class="fc"><i>156</i>&nbsp;		phi2 = phi.val;</b>
<i>157</i>&nbsp;
<b class="fc"><i>158</i>&nbsp;		dlam = lam_delta(lam2 - lam1); /* longitude difference [-Pi, Pi] */</b>
<i>159</i>&nbsp;
<b class="fc"><i>160</i>&nbsp;		if (PE_EQ(phi1, phi2) &amp;&amp; (PE_ZERO(dlam) || PE_EQ(PE_ABS(phi1), PE_PI2))) {</b>
<i>161</i>&nbsp;			/* Check that the points are not the same */
<b class="fc"><i>162</i>&nbsp;			if (p_dist != null)</b>
<b class="fc"><i>163</i>&nbsp;				p_dist.val = 0.0;</b>
<b class="fc"><i>164</i>&nbsp;			if (p_az12 != null)</b>
<b class="fc"><i>165</i>&nbsp;				p_az12.val = 0.0;</b>
<b class="fc"><i>166</i>&nbsp;			if (p_az21 != null)</b>
<b class="fc"><i>167</i>&nbsp;				p_az21.val = 0.0;</b>
<i>168</i>&nbsp;
<b class="fc"><i>169</i>&nbsp;			return;</b>
<b class="fc"><i>170</i>&nbsp;		} else if (PE_EQ(phi1, -phi2)) {</b>
<i>171</i>&nbsp;			/* Check if they are perfectly antipodal */
<b class="fc"><i>172</i>&nbsp;			if (PE_EQ(PE_ABS(phi1), PE_PI2)) {</b>
<i>173</i>&nbsp;				/* Check if they are at opposite poles */
<b class="fc"><i>174</i>&nbsp;				if (p_dist != null)</b>
<b class="fc"><i>175</i>&nbsp;					p_dist.val = 2.0 * q90(a, e2);</b>
<i>176</i>&nbsp;
<b class="fc"><i>177</i>&nbsp;				if (p_az12 != null)</b>
<b class="fc"><i>178</i>&nbsp;					p_az12.val = phi1 &gt; 0.0 ? lam_delta(PE_PI - lam_delta(lam2))</b>
<b class="fc"><i>179</i>&nbsp;							: lam_delta(lam2);</b>
<i>180</i>&nbsp;
<b class="fc"><i>181</i>&nbsp;				if (p_az21 != null)</b>
<b class="fc"><i>182</i>&nbsp;					p_az21.val = phi1 &gt; 0.0 ? lam_delta(lam2) : lam_delta(PE_PI</b>
<b class="fc"><i>183</i>&nbsp;							- lam_delta(lam2));</b>
<i>184</i>&nbsp;
<b class="fc"><i>185</i>&nbsp;				return;</b>
<b class="fc"><i>186</i>&nbsp;			} else if (PE_EQ(PE_ABS(dlam), PE_PI)) {</b>
<i>187</i>&nbsp;				/* Other antipodal */
<b class="fc"><i>188</i>&nbsp;				if (p_dist != null)</b>
<b class="fc"><i>189</i>&nbsp;					p_dist.val = 2.0 * q90(a, e2);</b>
<b class="fc"><i>190</i>&nbsp;				if (p_az12 != null)</b>
<b class="fc"><i>191</i>&nbsp;					p_az12.val = 0.0;</b>
<b class="fc"><i>192</i>&nbsp;				if (p_az21 != null)</b>
<b class="fc"><i>193</i>&nbsp;					p_az21.val = 0.0;</b>
<b class="fc"><i>194</i>&nbsp;				return;</b>
<i>195</i>&nbsp;			}
<i>196</i>&nbsp;		}
<i>197</i>&nbsp;
<b class="fc"><i>198</i>&nbsp;		if (PE_ZERO(e2)) /* Sphere */</b>
<i>199</i>&nbsp;		{
<i>200</i>&nbsp;			double cos_phi1, cos_phi2;
<i>201</i>&nbsp;			double sin_phi1, sin_phi2;
<i>202</i>&nbsp;
<b class="fc"><i>203</i>&nbsp;			cos_phi1 = Math.cos(phi1);</b>
<b class="fc"><i>204</i>&nbsp;			cos_phi2 = Math.cos(phi2);</b>
<b class="fc"><i>205</i>&nbsp;			sin_phi1 = Math.sin(phi1);</b>
<b class="fc"><i>206</i>&nbsp;			sin_phi2 = Math.sin(phi2);</b>
<i>207</i>&nbsp;
<b class="fc"><i>208</i>&nbsp;			if (p_dist != null) {</b>
<b class="fc"><i>209</i>&nbsp;				tem1 = Math.sin((phi2 - phi1) / 2.0);</b>
<b class="fc"><i>210</i>&nbsp;				tem2 = Math.sin(dlam / 2.0);</b>
<b class="fc"><i>211</i>&nbsp;				sigma = 2.0 * Math.asin(Math.sqrt(tem1 * tem1 + cos_phi1</b>
<i>212</i>&nbsp;						* cos_phi2 * tem2 * tem2));
<b class="fc"><i>213</i>&nbsp;				p_dist.val = sigma * a;</b>
<i>214</i>&nbsp;			}
<i>215</i>&nbsp;
<b class="fc"><i>216</i>&nbsp;			if (p_az12 != null) {</b>
<b class="fc"><i>217</i>&nbsp;				if (PE_EQ(PE_ABS(phi1), PE_PI2)) /* Origin at N or S Pole */</b>
<i>218</i>&nbsp;				{
<b class="nc"><i>219</i>&nbsp;					p_az12.val = phi1 &lt; 0.0 ? lam2 : lam_delta(PE_PI - lam2);</b>
<i>220</i>&nbsp;				} else {
<b class="fc"><i>221</i>&nbsp;					p_az12.val = Math.atan2(cos_phi2 * Math.sin(dlam), cos_phi1</b>
<b class="fc"><i>222</i>&nbsp;							* sin_phi2 - sin_phi1 * cos_phi2 * Math.cos(dlam));</b>
<i>223</i>&nbsp;				}
<i>224</i>&nbsp;			}
<i>225</i>&nbsp;
<b class="fc"><i>226</i>&nbsp;			if (p_az21 != null) {</b>
<b class="fc"><i>227</i>&nbsp;				if (PE_EQ(PE_ABS(phi2), PE_PI2)) /* Destination at N or S Pole */</b>
<i>228</i>&nbsp;				{
<b class="fc"><i>229</i>&nbsp;					p_az21.val = phi2 &lt; 0.0 ? lam1 : lam_delta(PE_PI - lam1);</b>
<i>230</i>&nbsp;				} else {
<b class="nc"><i>231</i>&nbsp;					p_az21.val = Math.atan2(cos_phi1 * Math.sin(dlam), sin_phi2</b>
<b class="nc"><i>232</i>&nbsp;							* cos_phi1 * Math.cos(dlam) - cos_phi2 * sin_phi1);</b>
<b class="nc"><i>233</i>&nbsp;					p_az21.val = lam_delta(p_az21.val + PE_PI);</b>
<i>234</i>&nbsp;				}
<i>235</i>&nbsp;			}
<i>236</i>&nbsp;
<b class="fc"><i>237</i>&nbsp;			return;</b>
<i>238</i>&nbsp;		}
<i>239</i>&nbsp;
<b class="fc"><i>240</i>&nbsp;		f = 1.0 - Math.sqrt(1.0 - e2);</b>
<b class="fc"><i>241</i>&nbsp;		boa = 1.0 - f;</b>
<i>242</i>&nbsp;
<b class="fc"><i>243</i>&nbsp;		eta1 = Math.atan(boa * Math.tan(phi1)); /* better reduced latitude */</b>
<b class="fc"><i>244</i>&nbsp;		sin_eta1 = Math.sin(eta1);</b>
<b class="fc"><i>245</i>&nbsp;		cos_eta1 = Math.cos(eta1);</b>
<i>246</i>&nbsp;
<b class="fc"><i>247</i>&nbsp;		eta2 = Math.atan(boa * Math.tan(phi2)); /* better reduced latitude */</b>
<b class="fc"><i>248</i>&nbsp;		sin_eta2 = Math.sin(eta2);</b>
<b class="fc"><i>249</i>&nbsp;		cos_eta2 = Math.cos(eta2);</b>
<i>250</i>&nbsp;
<b class="fc"><i>251</i>&nbsp;		prev = dlam;</b>
<b class="fc"><i>252</i>&nbsp;		test = dlam;</b>
<b class="fc"><i>253</i>&nbsp;		it = 0;</b>
<b class="fc"><i>254</i>&nbsp;		kind = 1;</b>
<b class="fc"><i>255</i>&nbsp;		lam_sph = dlam; /* v13 (Rapp ) */</b>
<i>256</i>&nbsp;
<i>257</i>&nbsp;		/* top of the long-line loop (kind = 1) */
<i>258</i>&nbsp;
<b class="fc"><i>259</i>&nbsp;		q_continue_looping = true;</b>
<b class="fc"><i>260</i>&nbsp;		while (q_continue_looping &amp;&amp; it &lt; 100) {</b>
<b class="fc"><i>261</i>&nbsp;			it = it + 1;</b>
<i>262</i>&nbsp;
<b class="fc"><i>263</i>&nbsp;			if (kind == 1) {</b>
<b class="fc"><i>264</i>&nbsp;				sin_lam_sph = Math.sin(lam_sph);</b>
<i>265</i>&nbsp;
<i>266</i>&nbsp;				/*
<i>267</i>&nbsp;				 * if ( PE_ABS(PE_PI - PE_ABS(dlam)) &lt; 2.0e-11 ) sin_lam_sph =
<i>268</i>&nbsp;				 * 0.0 no--troublesome
<i>269</i>&nbsp;				 */
<i>270</i>&nbsp;
<b class="fc"><i>271</i>&nbsp;				cos_lam_sph = Math.cos(lam_sph);</b>
<b class="fc"><i>272</i>&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="fc"><i>273</i>&nbsp;				temp = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="fc"><i>274</i>&nbsp;				sin_sigma = Math.sqrt(tem1 * tem1 + temp * temp); /*</b>
<i>275</i>&nbsp;																 * v14 (Rapp
<i>276</i>&nbsp;																 * 1.87)
<i>277</i>&nbsp;																 */
<b class="fc"><i>278</i>&nbsp;				cos_sigma = sin_eta1 * sin_eta2 + cos_eta1 * cos_eta2</b>
<i>279</i>&nbsp;						* cos_lam_sph; /* v15 (Rapp 1.88) */
<b class="fc"><i>280</i>&nbsp;				sigma = Math.atan2(sin_sigma, cos_sigma); /* (Rapp 1.89) */</b>
<i>281</i>&nbsp;
<b class="fc"><i>282</i>&nbsp;				if (PE_ABS(sin_sigma) &lt; eps) /* avoid division by 0 */</b>
<i>283</i>&nbsp;				{
<b class="nc"><i>284</i>&nbsp;					sin_azeq = cos_eta1 * cos_eta2 * sin_lam_sph</b>
<b class="nc"><i>285</i>&nbsp;							/ PE_SGN(eps, sin_sigma);</b>
<i>286</i>&nbsp;				} else {
<b class="fc"><i>287</i>&nbsp;					sin_azeq = cos_eta1 * cos_eta2 * sin_lam_sph / sin_sigma;</b>
<i>288</i>&nbsp;					/* v17 (Rapp 1.90) */
<i>289</i>&nbsp;				}
<i>290</i>&nbsp;
<b class="fc"><i>291</i>&nbsp;				cos2_azeq = 1.0 - sin_azeq * sin_azeq;</b>
<i>292</i>&nbsp;
<b class="fc"><i>293</i>&nbsp;				if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
<i>294</i>&nbsp;				{
<b class="fc"><i>295</i>&nbsp;					costm = cos_sigma - 2.0</b>
<b class="fc"><i>296</i>&nbsp;							* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
<i>297</i>&nbsp;				} else {
<b class="fc"><i>298</i>&nbsp;					costm = cos_sigma - 2.0 * (sin_eta1 * sin_eta2 / cos2_azeq);</b>
<i>299</i>&nbsp;					/* v18 (Rapp 1.91) */
<i>300</i>&nbsp;				}
<b class="fc"><i>301</i>&nbsp;				costm2 = costm * costm;</b>
<b class="fc"><i>302</i>&nbsp;				c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f / 16.0; /*</b>
<i>303</i>&nbsp;																				 * v10
<i>304</i>&nbsp;																				 * (
<i>305</i>&nbsp;																				 * Rapp
<i>306</i>&nbsp;																				 * 1.83
<i>307</i>&nbsp;																				 * )
<i>308</i>&nbsp;																				 */
<i>309</i>&nbsp;			}
<i>310</i>&nbsp;
<i>311</i>&nbsp;			/* entry point of the antipodal loop (kind = 2) */
<b class="fc"><i>312</i>&nbsp;			d = (1.0 - c)</b>
<i>313</i>&nbsp;					* f
<i>314</i>&nbsp;					* (sigma + c * sin_sigma
<i>315</i>&nbsp;							* (costm + cos_sigma * c * (2.0 * costm2 - 1.0)));
<i>316</i>&nbsp;			/* v11 (Rapp 1.84) */
<i>317</i>&nbsp;
<b class="fc"><i>318</i>&nbsp;			if (kind == 1) {</b>
<b class="fc"><i>319</i>&nbsp;				lam_sph = dlam + d * sin_azeq;</b>
<b class="fc"><i>320</i>&nbsp;				if (PE_ABS(lam_sph - test) &lt; tol) {</b>
<b class="fc"><i>321</i>&nbsp;					q_continue_looping = false;</b>
<b class="fc"><i>322</i>&nbsp;					continue;</b>
<i>323</i>&nbsp;				}
<i>324</i>&nbsp;
<b class="fc"><i>325</i>&nbsp;				if (PE_ABS(lam_sph) &gt; PE_PI) {</b>
<b class="fc"><i>326</i>&nbsp;					kind = 2;</b>
<b class="fc"><i>327</i>&nbsp;					lam_sph = PE_PI;</b>
<b class="fc"><i>328</i>&nbsp;					if (dlam &lt; 0.0) {</b>
<b class="fc"><i>329</i>&nbsp;						lam_sph = -lam_sph;</b>
<i>330</i>&nbsp;					}
<b class="fc"><i>331</i>&nbsp;					sin_azeq = 0.0;</b>
<b class="fc"><i>332</i>&nbsp;					cos2_azeq = 1.0;</b>
<b class="fc"><i>333</i>&nbsp;					test = 2.0;</b>
<b class="fc"><i>334</i>&nbsp;					prev = test;</b>
<i>335</i>&nbsp;
<b class="fc"><i>336</i>&nbsp;					sigma = PE_PI</b>
<b class="fc"><i>337</i>&nbsp;							- PE_ABS(Math.atan(sin_eta1 / cos_eta1)</b>
<b class="fc"><i>338</i>&nbsp;									+ Math.atan(sin_eta2 / cos_eta2));</b>
<b class="fc"><i>339</i>&nbsp;					sin_sigma = Math.sin(sigma);</b>
<b class="fc"><i>340</i>&nbsp;					cos_sigma = Math.cos(sigma);</b>
<b class="fc"><i>341</i>&nbsp;					c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f</b>
<i>342</i>&nbsp;							/ 16.0; /* v10 (Rapp 1.83) */
<i>343</i>&nbsp;
<b class="fc"><i>344</i>&nbsp;					if (PE_ABS(sin_azeq - prev) &lt; tol) {</b>
<b class="nc"><i>345</i>&nbsp;						q_continue_looping = false;</b>
<b class="nc"><i>346</i>&nbsp;						continue;</b>
<i>347</i>&nbsp;					}
<b class="fc"><i>348</i>&nbsp;					if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
<i>349</i>&nbsp;					{
<b class="nc"><i>350</i>&nbsp;						costm = cos_sigma</b>
<i>351</i>&nbsp;								- 2.0
<b class="nc"><i>352</i>&nbsp;								* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
<i>353</i>&nbsp;					} else {
<b class="fc"><i>354</i>&nbsp;						costm = cos_sigma - 2.0</b>
<i>355</i>&nbsp;								* (sin_eta1 * sin_eta2 / cos2_azeq);
<i>356</i>&nbsp;						/* v18 (Rapp 1.91) */
<i>357</i>&nbsp;					}
<b class="fc"><i>358</i>&nbsp;					costm2 = costm * costm;</b>
<b class="fc"><i>359</i>&nbsp;					continue;</b>
<i>360</i>&nbsp;				}
<i>361</i>&nbsp;
<b class="fc"><i>362</i>&nbsp;				if (((lam_sph - test) * (test - prev)) &lt; 0.0 &amp;&amp; it &gt; 5) {</b>
<i>363</i>&nbsp;					/* refined converge */
<b class="nc"><i>364</i>&nbsp;					lam_sph = (2.0 * lam_sph + 3.0 * test + prev) / 6.0;</b>
<i>365</i>&nbsp;				}
<b class="fc"><i>366</i>&nbsp;				prev = test;</b>
<b class="fc"><i>367</i>&nbsp;				test = lam_sph;</b>
<b class="fc"><i>368</i>&nbsp;				continue;</b>
<i>369</i>&nbsp;			} else /* kind == 2 */
<i>370</i>&nbsp;			{
<b class="fc"><i>371</i>&nbsp;				sin_azeq = (lam_sph - dlam) / d;</b>
<b class="fc"><i>372</i>&nbsp;				if (((sin_azeq - test) * (test - prev)) &lt; 0.0 &amp;&amp; it &gt; 5) {</b>
<i>373</i>&nbsp;					/* refined converge */
<b class="fc"><i>374</i>&nbsp;					sin_azeq = (2.0 * sin_azeq + 3.0 * test + prev) / 6.0;</b>
<i>375</i>&nbsp;				}
<b class="fc"><i>376</i>&nbsp;				prev = test;</b>
<b class="fc"><i>377</i>&nbsp;				test = sin_azeq;</b>
<b class="fc"><i>378</i>&nbsp;				cos2_azeq = 1.0 - sin_azeq * sin_azeq;</b>
<b class="fc"><i>379</i>&nbsp;				sin_lam_sph = sin_azeq * sin_sigma / (cos_eta1 * cos_eta2);</b>
<b class="fc"><i>380</i>&nbsp;				cos_lam_sph = -Math</b>
<b class="fc"><i>381</i>&nbsp;						.sqrt(PE_ABS(1.0 - sin_lam_sph * sin_lam_sph));</b>
<b class="fc"><i>382</i>&nbsp;				lam_sph = Math.atan2(sin_lam_sph, cos_lam_sph);</b>
<b class="fc"><i>383</i>&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="fc"><i>384</i>&nbsp;				temp = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="fc"><i>385</i>&nbsp;				sin_sigma = Math.sqrt(tem1 * tem1 + temp * temp);</b>
<b class="fc"><i>386</i>&nbsp;				cos_sigma = sin_eta1 * sin_eta2 + cos_eta1 * cos_eta2</b>
<i>387</i>&nbsp;						* cos_lam_sph;
<b class="fc"><i>388</i>&nbsp;				sigma = Math.atan2(sin_sigma, cos_sigma);</b>
<b class="fc"><i>389</i>&nbsp;				c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f / 16.0; /*</b>
<i>390</i>&nbsp;																				 * v10
<i>391</i>&nbsp;																				 * (
<i>392</i>&nbsp;																				 * Rapp
<i>393</i>&nbsp;																				 * 1.83
<i>394</i>&nbsp;																				 * )
<i>395</i>&nbsp;																				 */
<b class="fc"><i>396</i>&nbsp;				if (PE_ABS(sin_azeq - prev) &lt; tol) {</b>
<b class="fc"><i>397</i>&nbsp;					q_continue_looping = false;</b>
<b class="fc"><i>398</i>&nbsp;					continue;</b>
<i>399</i>&nbsp;				}
<b class="fc"><i>400</i>&nbsp;				if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
<i>401</i>&nbsp;				{
<b class="nc"><i>402</i>&nbsp;					costm = cos_sigma - 2.0</b>
<b class="nc"><i>403</i>&nbsp;							* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
<i>404</i>&nbsp;				} else {
<b class="fc"><i>405</i>&nbsp;					costm = cos_sigma - 2.0 * (sin_eta1 * sin_eta2 / cos2_azeq);</b>
<i>406</i>&nbsp;					/* v18 (Rapp 1.91) */
<i>407</i>&nbsp;				}
<b class="fc"><i>408</i>&nbsp;				costm2 = costm * costm;</b>
<b class="fc"><i>409</i>&nbsp;				continue;</b>
<i>410</i>&nbsp;			}
<i>411</i>&nbsp;		} /* End of while q_continue_looping */
<i>412</i>&nbsp;
<i>413</i>&nbsp;		/* Convergence */
<i>414</i>&nbsp;
<b class="fc"><i>415</i>&nbsp;		if (p_dist != null) {</b>
<i>416</i>&nbsp;			/*
<i>417</i>&nbsp;			 * Helmert 1880 from Vincenty&#39;s
<i>418</i>&nbsp;			 * &quot;Geodetic inverse solution between antipodal points&quot;
<i>419</i>&nbsp;			 */
<i>420</i>&nbsp;
<b class="fc"><i>421</i>&nbsp;			ep2 = 1.0 / (boa * boa) - 1.0;</b>
<b class="fc"><i>422</i>&nbsp;			bige = Math.sqrt(1.0 + ep2 * cos2_azeq); /* 15 */</b>
<b class="fc"><i>423</i>&nbsp;			bigf = (bige - 1.0) / (bige + 1.0); /* 16 */</b>
<b class="fc"><i>424</i>&nbsp;			biga = (1.0 + bigf * bigf / 4.0) / (1.0 - bigf); /* 17 */</b>
<b class="fc"><i>425</i>&nbsp;			bigb = bigf * (1.0 - 0.375 * bigf * bigf); /* 18 */</b>
<b class="fc"><i>426</i>&nbsp;			z = bigb / 6.0 * costm * (-3.0 + 4.0 * sin_sigma * sin_sigma)</b>
<i>427</i>&nbsp;					* (-3.0 + 4.0 * costm2);
<b class="fc"><i>428</i>&nbsp;			dsigma = bigb</b>
<i>429</i>&nbsp;					* sin_sigma
<i>430</i>&nbsp;					* (costm + bigb / 4.0
<i>431</i>&nbsp;							* (cos_sigma * (-1.0 + 2.0 * costm2) - z)); /* 19 */
<b class="fc"><i>432</i>&nbsp;			dist = (boa * a) * biga * (sigma - dsigma); /* 20 */</b>
<i>433</i>&nbsp;
<b class="fc"><i>434</i>&nbsp;			p_dist.val = dist;</b>
<i>435</i>&nbsp;		}
<i>436</i>&nbsp;
<b class="fc"><i>437</i>&nbsp;		if (p_az12 != null || p_az21 != null) {</b>
<b class="nc"><i>438</i>&nbsp;			if (kind == 2) /* antipodal */</b>
<i>439</i>&nbsp;			{
<b class="nc"><i>440</i>&nbsp;				az12 = sin_azeq / cos_eta1;</b>
<b class="nc"><i>441</i>&nbsp;				az21 = Math.sqrt(1.0 - az12 * az12);</b>
<b class="nc"><i>442</i>&nbsp;				if (temp &lt; 0.0) {</b>
<b class="nc"><i>443</i>&nbsp;					az21 = -az21;</b>
<i>444</i>&nbsp;				}
<b class="nc"><i>445</i>&nbsp;				az12 = Math.atan2(az12, az21);</b>
<b class="nc"><i>446</i>&nbsp;				tem1 = -sin_azeq;</b>
<b class="nc"><i>447</i>&nbsp;				tem2 = sin_eta1 * sin_sigma - cos_eta1 * cos_sigma * az21;</b>
<b class="nc"><i>448</i>&nbsp;				az21 = Math.atan2(tem1, tem2);</b>
<i>449</i>&nbsp;			} else /* long-line */
<i>450</i>&nbsp;			{
<b class="nc"><i>451</i>&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="nc"><i>452</i>&nbsp;				tem2 = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="nc"><i>453</i>&nbsp;				az12 = Math.atan2(tem1, tem2);</b>
<b class="nc"><i>454</i>&nbsp;				tem1 = -cos_eta1 * sin_lam_sph;</b>
<b class="nc"><i>455</i>&nbsp;				tem2 = sin_eta1 * cos_eta2 - cos_eta1 * sin_eta2 * cos_lam_sph;</b>
<b class="nc"><i>456</i>&nbsp;				az21 = Math.atan2(tem1, tem2);</b>
<i>457</i>&nbsp;			}
<i>458</i>&nbsp;
<b class="nc"><i>459</i>&nbsp;			if (p_az12 != null) {</b>
<b class="nc"><i>460</i>&nbsp;				p_az12.val = lam_delta(az12);</b>
<i>461</i>&nbsp;			}
<b class="nc"><i>462</i>&nbsp;			if (p_az21 != null) {</b>
<b class="nc"><i>463</i>&nbsp;				p_az21.val = lam_delta(az21);</b>
<i>464</i>&nbsp;			}
<i>465</i>&nbsp;		}
<b class="fc"><i>466</i>&nbsp;	}</b>
<i>467</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-02-27 21:44</div>
</div>
</body>
</html>
